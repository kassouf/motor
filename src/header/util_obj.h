#ifndef PMK_MOTOR_UTIL_OBJ_H
#define PMK_MOTOR_UTIL_OBJ_H

/*
#defines for errors 
*/
typedef int motor_err_t;
#define MOTOR_NO_ERROR 0
#define MOTOR_NULL_VECTOR_ERROR -1

/*
physical constants
*/
#define SQRT_3_2 (0.866025403784)

/*
conversion macros
*/
#define TO_RADIANS(x)(0.01745329252 * (x))

/*
  Indexs into the arrays
  ABC Space
*/
#define IA 0
#define IB 1
#define IC 2

/*
Alfa Beta Space
*/
#define IALFA 0
#define IBETA 1

/*
ID/IQ Space
*/
#define ID 0
#define IQ 1



#ifdef PMK_GCC
/*
define some attributes for GCC to optimize the library
*/
 #define likely(x)       __builtin_expect(!!(x), 1)
 #define unlikely(x)     __builtin_expect(!!(x), 0)

/*
define attribute for GCC to warn that the return value is unsed
*/
 #define MOTOR_FUNCTION __attribute__ ((warn_unused_result)) motor_err_t
#else
/*
if we don't have GCC, just defines these macros as "no-ops"
*/
 #define likely(x) (x)
 #define unlikely(x) (x)
/*
if we don't have GCC, just make the return type a motor_err_t
*/
 #define MOTOR_FUNCTION motor_err_t
#endif



/*
3Phase functions provided by motor library
*/

extern MOTOR_FUNCTION Convert_abc_to_alfabeta(const double *i_src, double *i_dest);
extern MOTOR_FUNCTION Convert_alfabeta_to_dq(const double *i_src, double theta, double *i_dest);
extern MOTOR_FUNCTION Convert_dq_to_alfabeta(const double *i_src, double theta, double *i_dest);
extern MOTOR_FUNCTION Convert_alfabeta_to_abc(const double *i_src, double *i_dest);

/*
  Parse_Error will parse the bits in the error field and print a summary of what went wrong.  
  Parameters:
  error is the error code generated by the motor library
  function is a user supplied string that will be used int he error reporting to deterime the "function name"
  quiet determines if the function will printout anything in the case of no error.  It will always print out a report if an error has occurred!
*/
extern void Parse_Error(motor_err_t error, char *function, int quiet);

#endif
